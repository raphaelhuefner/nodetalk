<!doctype html>
<html>
  <head>
    <title>stat display</title>
        
    <script src="/json.js"></script> <!-- for ie -->
    <script src="/socket.io/socket.io.js"></script>
    <script src="/underscore.js"></script>
    <script src="/raphael/raphael.js"></script>
    <script src="/g.raphael/g.raphael.js"></script>
    <script src="/g.raphael/g.line.js"></script>
    <script src="/g.raphael/g.line.js"></script>
  </head>
  <body>
    
    <script>
      var timeWindow = 30000;
      var basket = {}, previousBasket = {};
      var servertimeOffset = 0;

      window.setInterval(function exchangeBaskets() {
        var oldPreviousBasket = previousBasket;
        previousBasket = basket;
        basket = {};
        window.setTimeout(function () {
          delete oldPreviousBasket;
        }, 1000);
      }, timeWindow*2);

      function esc(msg){
        return msg.replace(/</g, '&lt;').replace(/>/g, '&gt;');
      };
      
      function mylog (obj) {
        if (window.console && console.log) console.log(obj);
      }
      
      var socket = new io.Socket(null, {port: parseInt(window.location.port) || 80, rememberTransport: false});
      socket.connect();

      socket.on('message', function(msg){
        if ('queue' in msg) {
          for (var i = 0, ii = msg.queue.length; i < ii; i++) {
            var event = msg.queue[i];
            var prefixSubBasket = basket[event.prefix] = basket[event.prefix] || [];
            var insertPos = _.sortedIndex(prefixSubBasket, event, function (event) {return event.time;});
            delete event.prefix;
            prefixSubBasket.splice(insertPos, 0, event);
          }
        }
        if ('servertime' in msg) {
          servertimeOffset = msg.servertime - Date.now();
//          console.log(servertimeOffset);
        }
      });
      
      socket.on('connect', function(){ mylog('Websocket: Connected'); });
      socket.on('disconnect', function(){ mylog('Websocket: Disconnected'); });
      socket.on('reconnect', function(){ mylog('Websocket: Reconnected to server'); });
      socket.on('reconnecting', function( nextRetry ){ mylog('Websocket: Attempting to re-connect to the server, next attempt in ' + nextRetry + 'ms'); });
      socket.on('reconnect_failed', function(){ mylog('Websocket: Reconnected to server FAILED.'); });

      var paper = Raphael(50, 50, 800, 200);

      function scrapeBasket(basket, prefix, leaf, horizon, lineData) {
        if (basket[prefix]) {
          var prefixSubBasket = basket[prefix];
          for (var i = 0, ii = prefixSubBasket.length; i < ii; i++) {
            if (prefixSubBasket[i].leaves[leaf] && (horizon < prefixSubBasket[i].time)) {
              lineData.x.push(prefixSubBasket[i].time - horizon);
              lineData.y.push(prefixSubBasket[i].leaves[leaf]);
            }
          }
        }
        return lineData;
      }

      function getDataLines(prefix, leaves) {
        var now = Date.now()
        var horizon = (now + servertimeOffset) - timeWindow;

        var dataLines = {};
        for (l in leaves) {
          var lineData = {x:[], y:[]};
          lineData.x.push(0); // avoid x-axis-jitter
          lineData.y.push(0); // avoid x-axis-jitter
          lineData = scrapeBasket(previousBasket, prefix, leaf, horizon, lineData);
          lineData = scrapeBasket(basket, prefix, leaf, horizon, lineData);
          lineData.x.push(timeWindow); // avoid x-axis-jitter
          lineData.y.push(0); // avoid x-axis-jitter
          lineData.y[0] = lineData.y[1];
          if (lineData.y[lineData.y.length-2]) {
            lineData.y[lineData.y.length-1] = lineData.y[lineData.y.length-2];
          }
          dataLines{leaves[l]} = lineData;
        }
        return dataLines;
      }

      var linechartLoadAvg = null;
      var textLoadAvg = null;
      var textLoadAvgLabel = [];

      window.setInterval(function redraw() {
        var leaves = ['1min', '5min', '15min'];
        var dataLines = getDataLines('systemLoad', leaves);
        linechartLoadAvg && linechartLoadAvg.remove();
        var x = [], y = [], colors = [], labels = [];
        for (l = 0, ll = leaves.length; l < ll; l++) {
          labels.push(leaves[l]);
          x.push(dataLines[leaves[l]].x);
          y.push(dataLines[leaves[l]].y);
          colors.push(Raphael.fn.g.colors[l]);
        }
        x.push([0]); // fixate y axis
        y.push([0]); // fixate y axis
        x.push([0]); // fixate y axis
        y.push([1]); // fixate y axis
        linechartLoadAvg = paper.g.linechart(30, 10, 720, 150, x, y, {shade: true, axis: "0 1 1 1", colors: colors});
        textLoadAvg && textLoadAvg.remove();
        textLoadAvg = paper.text(120, 20, "Load Average").attr({font:"12px 'Fontin Sans', Fontin-Sans, sans-serif"});
        textLoadAvg.attr("fill", "#f99");
        for (l = 0, ll = labels.length; l < ll; l++) {
          textLoadAvgLabel[l] && textLoadAvgLabel[l].remove();
          textLoadAvgLabel[l] = paper.text(120, 40 + (20*l), labels[l]).attr({font:"12px 'Fontin Sans', Fontin-Sans, sans-serif", color:'#f99'});
          textLoadAvgLabel[l].attr("fill", colors[l]);
        }
      }, 500);


    </script>
    
    <h1>stat display with socket.io</h1>
    <style>
      * { margin:0; padding:0; }
      body { height: 100%; width: 100%; font: 13px Helvetica, Arial; background: #FFF; position: relative;}
    </style>
    
  </body>
</html>
